### Описание исходных данных

Задача проводилась для функции:

$$ f(x, y) = 100*x - 1/(y + 0.01) + 1000*(y^2 +  3*x) $$

В качестве начальной функции я произвольно взял:

$$ u(x, y) = 5*x + 10*y $$

Измерения производились на процессоре: 12th Gen Intel(R) Core(TM) i5-12450H

Измерения проводились на сетках разного размера, с разным числом потоков и разными размерами блоков. На каждый инстанс было проведено 5 замеров

### Результаты измерений

| N | Threads | Time, sec ($ mean \pm 2*std $) | Block size | Acceleration |
| - | - | - | - | - |
| 300 | 1 | $ 8.38 \pm 0.7 $ | 1 | 1.0 |
| 300 | 4 | $ 7.2 \pm 0.03 $ | 1 | 1.16 |
| 300 | 8 | $ 9.05 \pm 0.08 $ | 1 | 0.93 |
| 300 | 1 | $ 5.15 \pm 0.05 $ | 32 | 1.0 |
| 300 | 4 | $ 2.68 \pm 0.05 $ | 32 | 1.92 |
| 300 | 8 | $ 2.77 \pm 0.07 $ | 32 | 1.86 |
| 300 | 1 | $ 5.18 \pm 0.05 $ | 64 | 1.0 |
| 300 | 4 | $ 2.87 \pm 0.03 $ | 64 | 1.8 |
| 300 | 8 | $ 3.45 \pm 0.13 $ | 64 | 1.5 |

Среднее улучшение при 8 потоках составило:  **1.43** 

| N | Threads | Time, sec ($ mean \pm 2*std $) | Block size | Acceleration |
| - | - | - | - | - |
| 500 | 1 | $ 13.69 \pm 1.76 $ | 1 | 1.0 |
| 500 | 4 | $ 6.99 \pm 0.12 $ | 1 | 1.96 |
| 500 | 8 | $ 7.79 \pm 0.26 $ | 1 | 1.76 |
| 500 | 1 | $ 6.76 \pm 0.08 $ | 32 | 1.0 |
| 500 | 4 | $ 2.5 \pm 0.07 $ | 32 | 2.7 |
| 500 | 8 | $ 2.45 \pm 0.03 $ | 32 | 2.76 |
| 500 | 1 | $ 6.81 \pm 0.26 $ | 64 | 1.0 |
| 500 | 4 | $ 2.81 \pm 0.07 $ | 64 | 2.42 |
| 500 | 8 | $ 2.85 \pm 0.08 $ | 64 | 2.39 |

Среднее улучшение при 8 потоках составило:  **2.33** 

| N | Threads | Time, sec ($ mean \pm 2*std $) | Block size | Acceleration |
| - | - | - | - | - |
| 1000 | 1 | $ 26.99 \pm 0.37 $ | 1 | 1.0 |
| 1000 | 4 | $ 7.49 \pm 0.07 $ | 1 | 3.6 |
| 1000 | 8 | $ 6.48 \pm 0.27 $ | 1 | 4.17 |
| 1000 | 1 | $ 9.44 \pm 0.14 $ | 32 | 1.0 |
| 1000 | 4 | $ 2.61 \pm 0.13 $ | 32 | 3.62 |
| 1000 | 8 | $ 1.95 \pm 0.02 $ | 32 | 4.84 |
| 1000 | 1 | $ 7.7 \pm 0.11 $ | 64 | 1.0 |
| 1000 | 4 | $ 2.55 \pm 0.1 $ | 64 | 3.02 |
| 1000 | 8 | $ 2.18 \pm 0.02 $ | 64 | 3.53 |

Среднее улучшение при 8 потоках составило:  **4.18** 

### Выводы

1) Улучшение производительности становится заметно с ростом размера сетки. Это связано с накладными расходами времени, которые нужны при распараллеливании

2) Добавление обработки по блокам улучшает производительность независимо от количества используемых процессов. В моем случае наиболее эффективным оказались блоки размера 32x32

3) На самой большой секте улучшение составило **4.16** раз, что похоже на таблтчные результаты из источника